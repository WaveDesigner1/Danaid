/**
 * SecureSessionManager - POPRAWIONA wersja dla Socket.IO
 * U≈ºywa UnifiedCrypto i SocketIOHandler zamiast WebSocketHandler
 */
class SecureSessionManager {
  constructor() {
    this.activeSessions = [];
    this.friends = [];
    this.onlineUsers = [];
    this.messages = {};
    this.currentSessionId = null;
    this.user = {
      id: sessionStorage.getItem('user_id'),
      username: sessionStorage.getItem('username'),
      isAdmin: sessionStorage.getItem('is_admin') === 'true',
      isLoggedIn: sessionStorage.getItem('isLoggedIn') === 'true'
    };

    // Inicjalizacja bazy danych
    this.initDatabase();
    this.setupSocketIOHandlers();

    // Callbacks
    this.onMessageReceived = null;
    this.onSessionsUpdated = null;
    this.onFriendsUpdated = null;
    this.onOnlineStatusChanged = null;
    this.onFriendRequestReceived = null;
    
    console.log("SecureSessionManager zainicjalizowany z Socket.IO", this.user);
  }

  /**
   * POPRAWIONA: Konfiguruje handlery dla SocketIOHandler
   */
  setupSocketIOHandlers() {
    // Poczekaj na za≈Çadowanie SocketIOHandler
    const setupHandlers = () => {
      if (!window.wsHandler) {
        console.error("SocketIOHandler nie jest dostƒôpny globalnie");
        return;
      }
      
      // POPRAWIONA: Obs≈Çuga nowych wiadomo≈õci z debugowaniem
      window.wsHandler.on('new_message', (data) => {
        console.log("üÜï [SOCKET] Otrzymano nowƒÖ wiadomo≈õƒá:", data);
        console.log("üÜï [SOCKET] Struktura danych:", {
          hasSessionToken: !!data.session_token,
          hasMessage: !!data.message,
          messageContent: data.message?.content,
          messageId: data.message?.id,
          senderId: data.message?.sender_id
        });
        
        try {
          // Sprawd≈∫ czy to nie nasza w≈Çasna wiadomo≈õƒá (echo)
          if (data.message && data.message.sender_id && 
              parseInt(data.message.sender_id) === parseInt(this.user.id)) {
            console.log("‚Ü©Ô∏è To nasza w≈Çasna wiadomo≈õƒá, pomijam");
            return;
          }
          
          // Wywo≈Çaj callback
          if (this.onMessageReceived) {
            this.onMessageReceived(data.session_token, data.message);
          } else {
            console.warn("‚ö†Ô∏è Brak callbacku onMessageReceived");
          }
          
          // Dodaj do lokalnego magazynu
          this.storeMessage(data.session_token, data.message);
          
        } catch (error) {
          console.error("‚ùå B≈ÇƒÖd przetwarzania wiadomo≈õci Socket.IO:", error);
        }
      });
      
      // Obs≈Çuga aktualizacji sesji
      window.wsHandler.on('session_update', (data) => {
        console.log("Aktualizacja sesji:", data);
        this.getActiveSessions();
      });
      
      // Obs≈Çuga zaprosze≈Ñ do znajomych
      window.wsHandler.on('friend_request', (data) => {
        console.log("Otrzymano zaproszenie do znajomych:", data);
        
        if (this.onFriendRequestReceived) {
          this.onFriendRequestReceived(data);
        }
      });
      
      // Obs≈Çuga zmian statusu online
      window.wsHandler.on('user_status_change', (data) => {
        const userId = data.user_id;
        const isOnline = data.is_online;
        this.updateOnlineStatus(userId, isOnline);
      });
      
      // Obs≈Çuga listy u≈ºytkownik√≥w online
      window.wsHandler.on('online_users', (data) => {
        this.onlineUsers = data.users || [];
        
        if (this.onOnlineStatusChanged) {
          this.onOnlineStatusChanged(this.onlineUsers);
        }
      });
      
      // DODANE: Obs≈Çuga b≈Çƒôd√≥w Socket.IO
      window.wsHandler.on('error', (error) => {
        console.error("‚ùå [SOCKET] B≈ÇƒÖd Socket.IO:", error);
      });

      // DODANE: Obs≈Çuga roz≈ÇƒÖczenia
      window.wsHandler.on('disconnect', (reason) => {
        console.warn("üîå [SOCKET] Roz≈ÇƒÖczono:", reason);
      });

      // DODANE: Test po≈ÇƒÖczenia
      window.wsHandler.on('connect', () => {
        console.log("‚úÖ [SOCKET] Po≈ÇƒÖczono - testowanie...");
        
        // Wy≈õlij ping test
        setTimeout(() => {
          if (window.wsHandler.send) {
            window.wsHandler.send('ping', { test: true });
            console.log("üèì Wys≈Çano ping test");
          }
        }, 1000);
      });
      
      console.log("‚úÖ Socket.IO handlers skonfigurowane");
    };

    // Spr√≥buj teraz, je≈õli nie to czekaj
    if (window.wsHandler) {
      setupHandlers();
    } else {
      // Poczekaj na za≈Çadowanie
      setTimeout(setupHandlers, 1000);
    }
  }

  /**
   * Aktualizuje status online u≈ºytkownika
   */
  updateOnlineStatus(userId, isOnline) {
    if (isOnline) {
      if (!this.onlineUsers.includes(userId)) {
        this.onlineUsers.push(userId);
      }
    } else {
      this.onlineUsers = this.onlineUsers.filter(id => id !== userId);
    }
    
    // Zaktualizuj status znajomych
    this.friends = this.friends.map(friend => {
      if (friend.user_id === userId) {
        return { ...friend, is_online: isOnline };
      }
      return friend;
    });
    
    if (this.onOnlineStatusChanged) {
      this.onOnlineStatusChanged(this.onlineUsers);
    }
  }

// Inicjalizuje bazƒô danych IndexedDB
  async initDatabase() {
    try {
      const request = indexedDB.open('SecureChatMessages', 1);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('messages')) {
          db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('sessions')) {
          db.createObjectStore('sessions', { keyPath: 'token' });
        }
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        console.log("Baza danych IndexedDB zainicjalizowana");
        this.loadMessagesFromStorage();
      };
      
      request.onerror = (event) => {
        console.error('B≈ÇƒÖd inicjalizacji IndexedDB:', event.target.error);
      };
    } catch (error) {
      console.error('Nie mo≈ºna utworzyƒá bazy danych:', error);
    }
  }

  // Pobieranie wiadomo≈õci z lokalnego magazynu
  async loadMessagesFromStorage() {
    if (!this.db) {
      console.error("Baza danych nie jest dostƒôpna");
      return;
    }
    
    try {
      const tx = this.db.transaction(['messages'], 'readonly');
      const store = tx.objectStore('messages');
      const messages = await new Promise((resolve, reject) => {
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      // Grupuj wiadomo≈õci wed≈Çug sesji
      messages.forEach(message => {
        const sessionToken = message.sessionToken;
        if (!this.messages[sessionToken]) {
          this.messages[sessionToken] = [];
        }
        this.messages[sessionToken].push(message);
      });
      
      console.log(`Za≈Çadowano wiadomo≈õci dla ${Object.keys(this.messages).length} sesji`);
    } catch (error) {
      console.error('B≈ÇƒÖd podczas ≈Çadowania wiadomo≈õci:', error);
    }
  }

  // Zapisywanie wiadomo≈õci do lokalnego magazynu
  async storeMessage(sessionToken, message) {
    if (!this.db) {
      console.error("Baza danych nie jest dostƒôpna");
      return false;
    }
    
    try {
      // Dodaj wiadomo≈õƒá do lokalnego stanu
      if (!this.messages[sessionToken]) {
        this.messages[sessionToken] = [];
      }
      
      // Sprawd≈∫ czy wiadomo≈õƒá ju≈º nie istnieje (unikaj duplikat√≥w)
      const exists = this.messages[sessionToken].find(m => 
        m.id === message.id || 
        (m.timestamp === message.timestamp && m.content === message.content && m.sender_id === message.sender_id)
      );
      
      if (exists) {
        console.log("üìù Wiadomo≈õƒá ju≈º istnieje, pomijam duplikat");
        return true;
      }
      
      this.messages[sessionToken].push(message);
      
      // Zapisz do IndexedDB
      const tx = this.db.transaction(['messages'], 'readwrite');
      const store = tx.objectStore('messages');
      
      await new Promise((resolve, reject) => {
        const request = store.add({
          ...message,
          sessionToken: sessionToken
        });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
      
      console.log("üíæ Wiadomo≈õƒá zapisana:", message.content?.substring(0, 50) + "...");
      return true;
    } catch (error) {
      console.error('B≈ÇƒÖd zapisywania wiadomo≈õci:', error);
      return false;
    }
  }

  /**
   * DODANA: Pobieranie lokalnych wiadomo≈õci z obs≈ÇugƒÖ deszyfrowania
   */
  getLocalMessages(sessionToken) {
    console.log('üì• getLocalMessages wywo≈Çane dla:', sessionToken);
    console.log('üíæ Dostƒôpne wiadomo≈õci:', Object.keys(this.messages));
    
    if (!sessionToken) {
      console.error('‚ùå Brak sessionToken');
      return {
        status: 'error',
        message: 'Brak tokenu sesji',
        messages: []
      };
    }
    
    // Sprawd≈∫ czy mamy wiadomo≈õci dla tej sesji
    if (!this.messages[sessionToken]) {
      console.log('üì≠ Brak wiadomo≈õci dla sesji:', sessionToken);
      return {
        status: 'success',
        messages: []
      };
    }
    
    const messages = this.messages[sessionToken];
    console.log(`üì® Znaleziono ${messages.length} wiadomo≈õci dla sesji ${sessionToken}`);
    
    // Posortuj wiadomo≈õci wed≈Çug czasu
    const sortedMessages = messages.sort((a, b) => {
      const timeA = new Date(a.timestamp).getTime();
      const timeB = new Date(b.timestamp).getTime();
      return timeA - timeB;
    });
    
    return {
      status: 'success',
      messages: sortedMessages
    };
  }

  /**
   * DODANA: Pobieranie i odszyfrowanie wiadomo≈õci z serwera
   */
  async fetchMessagesFromServer(sessionToken) {
    try {
      console.log('üåê Pobieranie wiadomo≈õci z serwera dla:', sessionToken);
      
      const response = await fetch(`/api/messages/${sessionToken}`, {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'B≈ÇƒÖd pobierania wiadomo≈õci');
      }
      
      // Odszyfruj wiadomo≈õci je≈õli sƒÖ zaszyfrowane
      const decryptedMessages = [];
      
      for (const message of data.messages || []) {
        try {
          if (message.content && message.iv && window.unifiedCrypto) {
            // Sprawd≈∫ czy mamy klucz sesji
            const sessionKeyBase64 = window.unifiedCrypto.getSessionKey(sessionToken);
            if (sessionKeyBase64) {
              const sessionKey = await window.unifiedCrypto.importSessionKey(sessionKeyBase64);
              const decryptedContent = await window.unifiedCrypto.decryptMessage(sessionKey, {
                data: message.content,
                iv: message.iv
              });
              
              message.content = decryptedContent;
            }
          }
          
          decryptedMessages.push(message);
        } catch (decryptError) {
          console.error('‚ùå B≈ÇƒÖd deszyfrowania wiadomo≈õci:', decryptError);
          // Dodaj wiadomo≈õƒá z b≈Çƒôdem deszyfrowania
          decryptedMessages.push({
            ...message,
            content: '[Nie mo≈ºna odszyfrowaƒá wiadomo≈õci]',
            decryption_error: true
          });
        }
      }
      
      // Zapisz do lokalnej pamiƒôci
      if (!this.messages[sessionToken]) {
        this.messages[sessionToken] = [];
      }
      
      // Po≈ÇƒÖcz z lokalnymi wiadomo≈õciami (unikaj duplikat√≥w)
      for (const message of decryptedMessages) {
        const exists = this.messages[sessionToken].find(m => 
          m.id === message.id || 
          (m.timestamp === message.timestamp && m.content === message.content)
        );
        
        if (!exists) {
          this.messages[sessionToken].push(message);
          // Zapisz te≈º do IndexedDB
          await this.storeMessage(sessionToken, message);
        }
      }
      
      console.log(`‚úÖ Pobrano i odszyfrowano ${decryptedMessages.length} wiadomo≈õci`);
      
      return {
        status: 'success',
        messages: this.messages[sessionToken]
      };
      
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd pobierania wiadomo≈õci z serwera:', error);
      return {
        status: 'error',
        message: error.message,
        messages: []
      };
    }
  }

/**
   * Inicjalizacja sesji czatu - ZAKTUALIZOWANA dla Socket.IO
   */
  async initSession(recipientId) {
    try {
      if (!this.user.id) {
        throw new Error("U≈ºytkownik nie jest zalogowany");
      }
      
      const response = await fetch('/api/session/init', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'same-origin',
        body: JSON.stringify({ recipient_id: recipientId })
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd inicjacji sesji: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'B≈ÇƒÖd inicjacji sesji');
      }
      
      const session = data.session;
      console.log("Sesja zainicjowana pomy≈õlnie:", session);
      
      // Aktualizuj listy
      await this.getActiveSessions();
      
      return {
        success: true,
        session: session
      };
    } catch (error) {
      console.error('B≈ÇƒÖd inicjacji sesji:', error);
      return {
        success: false,
        message: error.message
      };
    }
  }

  /**
   * Pobieranie aktywnych sesji
   */
  async getActiveSessions() {
    try {
      if (!this.user.id) {
        throw new Error("U≈ºytkownik nie jest zalogowany");
      }
      
      const response = await fetch('/api/sessions/active', {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd pobierania sesji: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'B≈ÇƒÖd pobierania sesji');
      }
      
      this.activeSessions = data.sessions;
      
      if (this.onSessionsUpdated) {
        this.onSessionsUpdated(this.activeSessions);
      }
      
      return {
        status: 'success',
        sessions: this.activeSessions
      };
    } catch (error) {
      console.error('B≈ÇƒÖd pobierania aktywnych sesji:', error);
      return {
        status: 'error',
        message: error.message
      };
    }
  }

  /**
   * Pobieranie klucza sesji - ZAKTUALIZOWANA implementacja z UnifiedCrypto
   */
  async retrieveSessionKey(sessionToken) {
    try {
      // Sprawd≈∫ czy UnifiedCrypto jest dostƒôpny
      if (!window.unifiedCrypto) {
        throw new Error('UnifiedCrypto nie jest dostƒôpny');
      }

      // Sprawd≈∫ czy mamy klucz prywatny
      if (!window.unifiedCrypto.hasPrivateKey()) {
        throw new Error('Brak klucza prywatnego');
      }

      const response = await fetch(`/api/session/${sessionToken}/key`, {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd pobierania klucza sesji: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'B≈ÇƒÖd pobierania klucza sesji');
      }
      
      // ZAKTUALIZOWANE: U≈ºywamy UnifiedCrypto zamiast starych modu≈Ç√≥w
      const sessionKeyBase64 = await window.unifiedCrypto.decryptSessionKey(data.encrypted_key);
      
      // Zapisz klucz sesji
      window.unifiedCrypto.storeSessionKey(sessionToken, sessionKeyBase64);
      
      // Potwierd≈∫ odebranie klucza
      await fetch(`/api/session/${sessionToken}/acknowledge_key`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'same-origin'
      });
      
      return {
        success: true,
        message: 'Klucz sesji odebrany i potwierdzony'
      };
    } catch (error) {
      console.error('B≈ÇƒÖd pobierania klucza sesji:', error);
      return {
        success: false,
        message: error.message
      };
    }
  }

  async sendMessage(sessionToken, content) {
    try {
      console.log('üöÄ [SENDMESSAGE] Rozpoczynam wysy≈Çanie wiadomo≈õci...');
      
      // Sprawd≈∫ UnifiedCrypto
      if (!window.unifiedCrypto) {
        throw new Error('UnifiedCrypto nie jest dostƒôpny');
      }

      // Sprawd≈∫ klucz sesji
      const sessionKeyBase64 = window.unifiedCrypto.getSessionKey(sessionToken);
      if (!sessionKeyBase64) {
        throw new Error('Brak klucza sesji');
      }
      
      // Znajd≈∫ sesjƒô
      const session = this.activeSessions.find(s => s.token === sessionToken);
      if (!session || !session.other_user?.user_id) {
        throw new Error('Nie znaleziono sesji lub danych odbiorcy');
      }
      
      console.log('‚úÖ Sesja OK:', {
        token: session.token,
        recipient_id: session.other_user.user_id,
        recipient_name: session.other_user.username
      });
      
      // Szyfrowanie
      const sessionKey = await window.unifiedCrypto.importSessionKey(sessionKeyBase64);
      const encryptedData = await window.unifiedCrypto.encryptMessage(sessionKey, content);
      
      // Konwersja do Base64
      let encryptedContent, ivBase64;
      
      if (typeof encryptedData.data === 'string') {
        encryptedContent = encryptedData.data;
      } else {
        const bytes = encryptedData.data instanceof ArrayBuffer 
          ? new Uint8Array(encryptedData.data)
          : encryptedData.data;
        encryptedContent = btoa(String.fromCharCode.apply(null, bytes));
      }
      
      if (typeof encryptedData.iv === 'string') {
        ivBase64 = encryptedData.iv;
      } else {
        const ivBytes = encryptedData.iv instanceof ArrayBuffer 
          ? new Uint8Array(encryptedData.iv)
          : encryptedData.iv;
        ivBase64 = btoa(String.fromCharCode.apply(null, ivBytes));
      }
      
      console.log('üìä Dane do wys≈Çania:', {
        session_token: sessionToken,
        recipient_id: session.other_user.user_id,
        content_length: encryptedContent.length,
        iv_length: ivBase64.length
      });
      
      // Payload dla Railway
      const payload = {
        session_token: sessionToken,
        recipient_id: parseInt(session.other_user.user_id),
        content: encryptedContent,
        iv: ivBase64
      };
      
      // Headers
      const headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        'Cache-Control': 'no-cache'
      };
      
      console.log('üì§ Wysy≈Çanie wiadomo≈õci...');
      
      const response = await fetch('/api/message/send', {
        method: 'POST',
        headers: headers,
        credentials: 'same-origin',
        body: JSON.stringify(payload)
      });
      
      console.log('üì° Odpowied≈∫ serwera:', response.status, response.statusText);
      
      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}`;
        
        try {
          const responseText = await response.text();
          console.error('‚ùå B≈ÇƒÖd response:', responseText);
          
          try {
            const errorDetails = JSON.parse(responseText);
            errorMessage = errorDetails.message || errorDetails.error || errorMessage;
          } catch (e) {
            errorMessage = responseText.length > 100 
              ? responseText.substring(0, 100) + '...' 
              : responseText;
          }
        } catch (e) {
          console.error('‚ùå Nie mo≈ºna odczytaƒá odpowiedzi b≈Çƒôdu');
        }
        
        throw new Error(`B≈ÇƒÖd serwera: ${errorMessage}`);
      }
      
      const data = await response.json();
      console.log('‚úÖ Sukces:', data);
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'API zwr√≥ci≈Ço b≈ÇƒÖd');
      }
      
      // Dodaj do lokalnego stanu
      const newMessage = {
        id: data.message?.id || Date.now().toString(),
        sender_id: parseInt(this.user.id),
        content: content,
        timestamp: data.message?.timestamp || new Date().toISOString(),
        is_mine: true
      };
      
      await this.storeMessage(sessionToken, newMessage);
      
      console.log('‚úÖ Wiadomo≈õƒá wys≈Çana i zapisana lokalnie!');
      
      return {
        status: 'success',
        message: 'Wiadomo≈õƒá wys≈Çana',
        messageData: newMessage
      };
      
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd wysy≈Çania wiadomo≈õci:', error);
      return {
        status: 'error',
        message: error.message
      };
    }
  }

/**
   * Pobieranie listy znajomych
   */
  async fetchFriends() {
    try {
      const response = await fetch('/api/friends', {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd pobierania znajomych: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status !== 'success') {
        throw new Error(data.message || 'B≈ÇƒÖd pobierania znajomych');
      }
      
      this.friends = data.friends;
      
      if (this.onFriendsUpdated) {
        this.onFriendsUpdated(this.friends);
      }
      
      return {
        status: 'success',
        friends: this.friends
      };
    } catch (error) {
      console.error('B≈ÇƒÖd pobierania znajomych:', error);
      return {
        status: 'error',
        message: error.message
      };
    }
  }

  /**
   * Wysy≈Ça zaproszenie do znajomych
   */
  async sendFriendRequest(username) {
    try {
      if (!username || !username.trim()) {
        throw new Error('Podaj nazwƒô u≈ºytkownika');
      }
      
      if (!this.user.id) {
        throw new Error('U≈ºytkownik nie jest zalogowany');
      }
      
      const response = await fetch('/api/friend_requests', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'same-origin',
        body: JSON.stringify({ username: username.trim() })
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status === 'success') {
        // Od≈õwie≈º listƒô znajomych
        await this.fetchFriends();
        
        return {
          success: true,
          message: data.message || 'Zaproszenie wys≈Çane pomy≈õlnie'
        };
      } else {
        throw new Error(data.message || 'B≈ÇƒÖd wysy≈Çania zaproszenia');
      }
    } catch (error) {
      console.error('B≈ÇƒÖd wysy≈Çania zaproszenia:', error);
      
      return {
        success: false,
        message: error.message
      };
    }
  }
  
  /**
   * Pobiera oczekujƒÖce zaproszenia do znajomych
   */
  async getPendingFriendRequests() {
    try {
      const response = await fetch('/api/friend_requests/pending', {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status === 'success') {
        return {
          success: true,
          requests: data.requests || []
        };
      } else {
        throw new Error(data.message || 'B≈ÇƒÖd pobierania zaprosze≈Ñ');
      }
    } catch (error) {
      console.error('B≈ÇƒÖd pobierania zaprosze≈Ñ:', error);
      
      return {
        success: false,
        message: error.message,
        requests: []
      };
    }
  }
  
  /**
   * Akceptuje zaproszenie do znajomych
   */
  async acceptFriendRequest(requestId) {
    try {
      const response = await fetch(`/api/friend_requests/${requestId}/accept`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error(`B≈ÇƒÖd HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status === 'success') {
        // Od≈õwie≈º listƒô znajomych
        await this.fetchFriends();
        
        return {
          success: true,
          message: data.message || 'Zaproszenie zaakceptowane'
        };
      } else {
        throw new Error(data.message || 'B≈ÇƒÖd akceptacji zaproszenia');
      }
    } catch (error) {
      console.error('B≈ÇƒÖd akceptacji zaproszenia:', error);
      
      return {
        success: false,
        message: error.message
      };
    }
  }

  /**
   * DODANA: Odszyfrowanie i zapis przychodzƒÖcych wiadomo≈õci
   */
  async decryptAndStoreMessage(sessionToken, message) {
    try {
      console.log('üîê Pr√≥ba odszyfrowania wiadomo≈õci:', {
        sessionToken,
        hasContent: !!message.content,
        hasIv: !!message.iv
      });
      
      // Je≈õli wiadomo≈õƒá jest zaszyfrowana i mamy klucz
      if (message.content && message.iv && window.unifiedCrypto) {
        const sessionKeyBase64 = window.unifiedCrypto.getSessionKey(sessionToken);
        
        if (sessionKeyBase64) {
          const sessionKey = await window.unifiedCrypto.importSessionKey(sessionKeyBase64);
          message.content = await window.unifiedCrypto.decryptMessage(sessionKey, {
            data: message.content,
            iv: message.iv
          });
          console.log('‚úÖ Wiadomo≈õƒá odszyfrowana:', message.content?.substring(0, 50) + "...");
        } else {
          console.warn('‚ö†Ô∏è Brak klucza sesji dla:', sessionToken);
        }
      }
      
      // Zapisz do lokalnej pamiƒôci i IndexedDB
      await this.storeMessage(sessionToken, message);
      
      console.log('‚úÖ Wiadomo≈õƒá odszyfrowana i zapisana');
      
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd deszyfrowania wiadomo≈õci:', error);
      
      // Zapisz z informacjƒÖ o b≈Çƒôdzie
      message.content = '[Nie mo≈ºna odszyfrowaƒá]';
      message.decryption_error = true;
      await this.storeMessage(sessionToken, message);
    }
  }

  /**
   * Obs≈Çuguje wylogowanie u≈ºytkownika - ZAKTUALIZOWANA
   */
  async logout() {
    try {
      console.log('üö™ Rozpoczynam wylogowanie...');
      
      // 1. Wyczy≈õƒá klucze kryptograficzne
      if (window.unifiedCrypto) {
        window.unifiedCrypto.clearAllKeys();
        console.log('üîë Klucze kryptograficzne wyczyszczone');
      }
      
      // 2. Roz≈ÇƒÖcz Socket.IO
      if (window.wsHandler) {
        window.wsHandler.disconnect();
        console.log('üîå Socket.IO roz≈ÇƒÖczony');
      }
      
      // 3. Wyczy≈õƒá dane lokalne
      localStorage.clear();
      sessionStorage.clear();
      console.log('üíæ Pamiƒôƒá lokalna wyczyszczona');
      
      // 4. Wyczy≈õƒá lokalne dane aplikacji
      this.activeSessions = [];
      this.friends = [];
      this.messages = {};
      
      // 5. Zamknij bazƒô danych
      if (this.db) {
        this.db.close();
        console.log('üóÑÔ∏è Baza danych zamkniƒôta');
      }
      
      // 6. Ma≈Çe op√≥≈∫nienie ≈ºeby wszystko siƒô wykona≈Ço
      await new Promise(resolve => setTimeout(resolve, 500));
      
      console.log('‚úÖ Wylogowanie zako≈Ñczone, przekierowujƒô...');
      
    } catch (error) {
      console.error('‚ùå B≈ÇƒÖd podczas wylogowania:', error);
    } finally {
      // 7. ZAWSZE przekieruj na endpoint logout (kt√≥ry przekieruje na /)
      console.log('üîÑ Przekierowanie na /logout...');
      window.location.href = '/logout';
    }
  }
// Inicjalizacja globalnego SessionManager
window.sessionManager = new SecureSessionManager();
